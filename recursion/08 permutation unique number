🧠 Permutations (All Possible Arrangements)
💡 Goal
Given an array nums, return all possible permutations — different ways to arrange all elements.
Example:
[1, 2, 3] → [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]

🔹 Core Idea
At each step:
Pick one element that hasn’t been used yet.
Add it to the current permutation.
Recurse for the remaining elements.
Then backtrack (remove it) and try another choice.
We keep a set (st) to track which elements are already used in the current path.

⚙️ Complexity (Simple Terms)
Total permutations: n!
Each permutation takes O(n) to build.
🕒 Time: O(n × n!)
💾 Space: O(n) (for recursion + tracking used elements)

class Solution {
public:
    void solve(int n, unordered_set<int>& used, vector<int>& curr,
               vector<vector<int>>& ans, vector<int>& nums) {
        // Base case: one full permutation is ready
        if (curr.size() == n) {
            ans.push_back(curr);
            return;
        }

        // Try placing each unused number
        for (int i = 0; i < n; i++) {
            if (used.find(nums[i]) == used.end()) {
                used.insert(nums[i]);           // mark as used
                curr.push_back(nums[i]);        // choose
                solve(n, used, curr, ans, nums); // recurse
                curr.pop_back();                // undo (backtrack)
                used.erase(nums[i]);            // unmark
            }
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> curr;
        unordered_set<int> used;
        int n = nums.size();

        solve(n, used, curr, ans, nums);
        return ans;
    }
};
