ğŸ§© Permutation II â€” Unique Permutations (Leetcode 47)
ğŸ” Problem Description
Given an array nums that may contain duplicate elements, return all unique permutations of nums.
The answer can be returned in any order.

ğŸ’¡ Approach (Backtracking with Sorting + Used Array)
Sort the array â†’ so that duplicate elements come next to each other.
Use a boolean used[] array to track which indices are already part of the current permutation.

At every recursive step:
Skip any element already used.
Skip a duplicate element if itâ€™s the same as the previous and the previous is not yet used (!used[i-1]).
When the current permutationâ€™s length equals nums.size(), add it to the result.
Backtrack by removing the last added element and marking it unused again.

ğŸ§  Intuition
Sorting + the duplicate-skip condition ensures each unique number is chosen in a specific order,
so no duplicate permutations are generated.

ğŸ§® Time Complexity
O(N Ã— N!) â†’ each of the N! permutations takes O(N) time to copy.
Sorting adds O(N log N) (negligible compared to N!).

ğŸ’¾ Space Complexity
O(N) â†’ recursion stack + used[] array.

class Solution {
public:
    void solve(vector<int>& nums, vector<int>& curr, vector<vector<int>>& ans, vector<bool>& used) {
        if (curr.size() == nums.size()) {
            ans.push_back(curr);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;

            used[i] = true;
            curr.push_back(nums[i]);
            solve(nums, curr, ans, used);
            curr.pop_back();
            used[i] = false;
        }
    }

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        vector<int> curr;
        vector<bool> used(nums.size(), false);
        solve(nums, curr, ans, used);
        return ans;
    }
};
