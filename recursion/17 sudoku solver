ğŸ§© Sudoku Solver â€” Backtracking
ğŸ”¹ Problem Statement

Given a partially filled 9Ã—9 Sudoku board, fill the empty cells (represented by '.') so that:
Each row contains digits 1â€“9 without repetition.
Each column contains digits 1â€“9 without repetition.
Each of the nine 3Ã—3 subgrids also contains digits 1â€“9 without repetition.

ğŸ”¹ Intuition â€” â€œFill and Backtrackâ€

Think of Sudoku solving as placing one number at a time and moving forward only if the board remains valid.
If at any point it becomes invalid, go back (backtrack) and try another number.

ğŸ”¹ Approach (Step-by-Step)

Find an empty cell ('.')
Start from the top-left corner and move cell by cell.
Try placing digits '1' to '9'
For each digit, check if placing it keeps the board valid:
No duplicate in the row
No duplicate in the column
No duplicate in the 3Ã—3 subgrid
If valid, place the number and move to the next cell.
If not valid, try the next number.
If no number fits, backtrack â€” reset the cell to '.' and go one step back.
Continue until the entire board is filled.

ğŸ”¹ Helper Function â€” isvalid()

Checks whether a given character can be placed safely at (row, col):
Loops through the row and column.
Finds the top-left index of the 3Ã—3 subgrid using:

start_row = (row / 3) * 3;
start_col = (col / 3) * 3;

Checks all 9 cells in that 3Ã—3 grid.

ğŸ”¹ Recursive Function â€” solve()

Base case:
If row == 9, board is fully filled â†’ return true.

Recursive case:

Move to the next cell (next_row, next_col).
If the current cell is pre-filled, skip it.
Otherwise, try placing digits '1' to '9'.
For each valid placement â†’ recurse forward.
If recursion fails â†’ undo (backtrack).

ğŸ”¹ Time and Space Complexity

Time Complexity: O(9^(n*n)) in the worst case
(Each cell tries up to 9 possibilities recursively)

Space Complexity: O(1)
(Solves the board in-place, uses recursion stack only)

ğŸ”¹ Key Takeaways âœ¨

Always skip already filled cells.
Use row / 3 Ã— 3 and col / 3 Ã— 3 to locate subgrids.
Backtracking is just â€œtrying everything and undoing what doesnâ€™t work.â€
Clean recursion: start from (0,0) and let recursion explore the board.

class Solution {
public:
    bool isvalid(int row , int col , char ch , vector<vector<char>>& board) {
        // Row check 
        for(int j = 0 ; j < 9 ; j++){
            if(board[row][j] == ch) return false;
        }

        // Column check
        for(int i = 0 ; i < 9 ; i++){
            if(board[i][col] == ch) return false;
        }

        // 3x3 grid check
        int start_row = (row / 3) * 3;
        int start_col = (col / 3) * 3;
        for(int i = start_row ; i < start_row + 3 ; i++){
            for(int j = start_col ; j < start_col + 3 ; j++){
                if(board[i][j] == ch) return false;
            }
        }
        return true;
    }

    bool solve(int row , int col , vector<vector<char>>& board) {
        if(row == 9) return true; // Solved all rows

        int next_row = row;
        int next_col = col + 1;
        if(next_col == 9){
            next_row++;
            next_col = 0;
        }

        if(board[row][col] != '.') 
            return solve(next_row, next_col, board); // Skip filled cell

        for(char ch = '1'; ch <= '9'; ch++){
            if(isvalid(row, col, ch, board)){
                board[row][col] = ch;
                if(solve(next_row, next_col, board)) return true;
                board[row][col] = '.'; // Backtrack
            }
        }

        return false;
    }

    void solveSudoku(vector<vector<char>>& board) {
        solve(0, 0, board);
    }
};
