â™ Knightâ€™s Tour Configuration â€” Notes
ğŸ§© Problem Description:

You are given an n x n chessboard containing integers from 0 to nÂ² - 1.
Each cell represents the step number of a knightâ€™s move.

Starting from cell (0,0) (which should contain 0),
you must check whether this configuration forms a valid knightâ€™s tour â€”
meaning the knight can move legally from one number to the next (0 â†’ 1 â†’ 2 â†’ ... â†’ nÂ²âˆ’1).

ğŸ’¡ Intuition:

A knight in chess moves in an â€œLâ€ shape â€” two steps in one direction and one in the perpendicular direction.
That gives 8 possible moves from any cell.
To verify a valid tour:
Start at (0,0) which must have 0.
Recursively check whether you can reach the cell that contains the next number (idx + 1) using valid knight moves.
Continue until you reach the final number nÂ² âˆ’ 1.
If all positions are valid, return true.

âš™ï¸ Approach (Recursive Backtracking)

Base Case:

If the current position is outside the board or the value doesnâ€™t match the expected idx, return false.
If idx == target (nÂ² âˆ’ 1), return true â€” we reached the end successfully.

Recursive Case:

From the current cell, explore all 8 possible knight moves:

(-2, -1), (-2, +1),
(-1, -2), (-1, +2),
(+1, -2), (+1, +2),
(+2, -1), (+2, +1)


For each move, call the recursive function for idx + 1.
If any path returns true, the configuration is valid.

ğŸ§  Why newRow and newCol are used

We use temporary variables to store new positions instead of changing row and col directly â€”
because each recursive call should explore a separate path independently.

ğŸ•’ Time Complexity:

O(8â¿) in the worst case
(because from each position we can explore up to 8 directions recursively)

ğŸ’¾ Space Complexity:
O(nÂ²) â€” for recursion depth and the chessboard storage.

ğŸš€ Key Takeaways for Future:

When exploring grid-based problems, always check bounds and conditions first.
Use temporary coordinates (newRow, newCol) to avoid overwriting current state.
Knightâ€™s moves are a good example of backtracking on non-linear movement.
Always confirm base conditions to prevent infinite recursion.

class Solution {
public:
    bool solve(int row, int col, int n, int idx, int target,
               vector<pair<int,int>>& direction, vector<vector<int>>& grid) {

        // Base condition
        if (row < 0 || row >= n || col < 0 || col >= n || grid[row][col] != idx)
            return false;

        if (idx == target)
            return true;

        // Explore 8 possible knight moves
        for (int i = 0; i < 8; i++) {
            int newRow = row + direction[i].first;
            int newCol = col + direction[i].second;
            if (solve(newRow, newCol, n, idx + 1, target, direction, grid))
                return true;
        }

        return false;
    }

    bool checkValidGrid(vector<vector<int>>& grid) {
        int n = grid.size();
        int target = (n * n) - 1;
        int idx = 0;

        // 8 knight moves
        vector<pair<int,int>> direction = { 
            {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},
            {1, -2}, {1, 2}, {2, -1}, {2, 1}
        };

        return solve(0, 0, n, idx, target, direction, grid);
    }
};
