üîπ Increasing Subsequences (LeetCode 491)

Problem:
Given an integer array nums, return all different possible non-decreasing subsequences (length ‚â• 2).
You can return the answer in any order.

üß† Key Idea

We use backtracking to build all possible subsequences that are non-decreasing.
At each recursion level, we:
Keep the current sequence in curr.
Add it to ans when its size ‚â• 2.
For each index i, only:
Choose nums[i] if it‚Äôs ‚â• last element of curr (to keep non-decreasing order).
Ensure nums[i] isn‚Äôt used again at the same recursion level using a set.

üí° Why We Use set Instead of Sorting

In problems like Subset II, we can sort the array first and then skip duplicates easily using:
if (i > idx && nums[i] == nums[i - 1]) continue;


But here we can‚Äôt sort, because sorting would change the original order, and we‚Äôd lose the increasing sequence property.
So instead, we use a set inside each recursive call to avoid taking the same number twice at the same level:

unordered_set<int> st;


This ensures:

No duplicate subsequences are formed.
The relative order of elements stays the same.

‚è±Ô∏è Complexity

Time: O(2‚Åø) (all subsequences)
Space: O(n) recursion + O(n) for set

üîç Difference Summary
                                    Problem	Can Sort?	                                                                      Duplicate Handling Condition
Subset	‚úÖ                          Optional	                                                                              No duplicates	none
Subset II	‚úÖ         	            Yes	Skip duplicates using if (i > idx && nums[i] == nums[i-1]) continue;                Order doesn‚Äôt matter
Increasing Subsequences	‚ùå No	      Use unordered_set inside recursion	                                                    Order must remain non-decreasing


class Solution {
public:
    void solve(int idx, int n, vector<int>& curr, vector<vector<int>>& ans, vector<int>& nums) {
        if (curr.size() >= 2)
            ans.push_back(curr);

        unordered_set<int> st; // avoid duplicates at this recursion level

        for (int i = idx; i < n; i++) {
            if (st.find(nums[i]) == st.end()) {
                if (curr.empty() || nums[i] >= curr.back()) {
                    st.insert(nums[i]);
                    curr.push_back(nums[i]);
                    solve(i + 1, n, curr, ans, nums);
                    curr.pop_back();
                }
            }
        }
    }

    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<vector<int>> ans, curr;
        solve(0, nums.size(), curr, ans, nums);
        return ans;
    }
};


