ğŸ”¹ Palindrome Partitioning

Problem:
Given a string s, partition it so that every substring in the partition is a palindrome.
Return all possible palindrome partitions.

ğŸ§  Approach (Simple Explanation)

We use backtracking to explore every way we can cut the string.
Start from the first index idx = 0.
Try every possible end index i from idx to the end of the string.
For each substring s[idx..i]:
Check if itâ€™s a palindrome.
If yes â†’ add it to the current list (curr) and recurse from i + 1.
When we reach the end of the string (idx == n), that means all chosen substrings form one valid partition â†’ add it to ans.
After that, backtrack â€” remove the last added substring and try other cuts.

Complexity

Time: O(2â¿ * n) (for all partitions and palindrome checks)
Space: O(n) recursion + O(n) current path

class Solution {
public:
    bool ispalindrome(string &s , int l , int r){
        while (l < r)
            if (s[l++] != s[r--]) return false;
        return true;
    }

    void solve(int idx, int n , string &s , vector<string> &curr , vector<vector<string>> &ans){
        if (idx == n) {
            ans.push_back(curr);
            return;
        }

        for (int i = idx; i < n; i++) {
            if (ispalindrome(s, idx, i)) {
                curr.push_back(s.substr(idx, i - idx + 1));
                solve(i + 1, n, s, curr, ans);
                curr.pop_back(); // backtrack
            }
        }
    }

    vector<vector<string>> partition(string s) {
        vector<vector<string>> ans;
        vector<string> curr;
        solve(0, s.size(), s, curr, ans);
        return ans;
    }
};
